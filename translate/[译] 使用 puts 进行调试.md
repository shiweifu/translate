翻译自：[I am a puts debuggerer | Tenderlove Making](https://tenderlovemaking.com/2016/02/05/i-am-a-puts-debuggerer.html)



## 我喜欢使用 puts 进行调试



我是一名 `puts` 调试用户。我这么说，并不是诋毁使用真正调试器进行调试的人。我认为真正的调试器是很棒的，我只是从来没有花时间去把他们学好，哪怕一个。每次，当我有一段时间没有使用它们的时候，再次尝试使用它们，我都需要重新学习该如何使用。不管怎样，我想和你分享一些关于我使用 puts 进行调试的技巧。每当我不明白某件事情如何运行，而我又想搞懂他们的时候，我就会使用这些技巧进行调试。以下分享的内容，绝对不是“最佳实践”，当您使用这些代码调试完之后，应该把这些调试代码清理干净。这适用于任何情况。注意，我说`任何情况`。全局变量，重新定义方法，增加条件，操作加载路径，猴子补丁，打印调试堆栈，等任何情况。



我视图举出真实情况下存在的例子。然而，这些例子中，许多都来自我在 Rails 中，调试安全问题的时候。所以，请复用我所展示的技术，而不是直接使用我所提供的代码。我所调试的代码，是坏的，我不想你使用他。



我尝试在每一章节，描述一个具体遇到的问题，并用这个问题作为章节名称，其中的内容，是我所使用的解决方案。



另外，我放弃使用一致的声音，这是一篇日志，我不在乎（严谨）。



## 我知道我在哪，但是不知道怎么来的



有时候，我知道在调试什么问题，并定位了问题，但是，并不知道我是怎么来的。此时，我会直接 `puts caller`，来获取栈调用。



```
  LOOKUP           = Hash.new { |h, k| h[k] = Type.new(k) unless k.blank? }
```



但我需要知道默认块是如何被调用的，所以我这样做：



```
  LOOKUP           = Hash.new { |h, k|
    puts "#" * 90
    puts caller
    puts "#" * 90
    h[k] = Type.new(k) unless k.blank?
  }
```



上面的代码，将会输出 90 个散列标签，然后是调用堆栈，接着还是 90 个散列标签。这样，如果它被调用多次，我就可以很容易区分调用堆栈。注意，我叫它们“散列标签”，是为了惹恼你。














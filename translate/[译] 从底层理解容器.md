[Learning Containers From The Bottom Up (iximiuz.com)](https://iximiuz.com/en/posts/container-learning-path/)



当我在2015年开始使用容器时，我最初的理解是，它们只是启动时间低于秒的轻量级虚拟机。有了这样一个粗略的想法，就很容易按照互联网上的教程，学习如何将Python或Node.js应用程序放入容器中。但是很快，我意识到把容器看作vm是一种过于简单化的做法，这是有风险的，因为我无法做出判断：



- 容器可以做什么，不能做什么
- 什么是容器的习惯用法，什么不是
- 用集装箱运输什么安全，什么不安全。



由于“容器是VM”的抽象被证明是相当有漏洞的，我不得不开始研究这项技术的内部原理，以了解容器到底是什么，而Docker是最明显的出发点。但是Docker是一个做各种各样事情的庞然大物，而Docker运行nginx表面上的简单性可能是欺骗性的。有很多关于Docker的资料，但大部分都是：



- 容器可以做什么，不能做什么
- 什么是容器的惯用方法，什么是不合理的方法
- 什么是安全运行容器的环境，什么是不安全的环境



由于”容器是VM“的抽象被证明是相当有漏洞的，我不得不开始研究这项技术的内部原理，以了解容器到底是什么，而Docker是最明显的出发点。但是Docker是一个做各种各样事情的庞然大物，而Docker运行nginx表面上的简单性可能是欺骗性的。有很多关于Docker的资料，但大部分都是：



- 要么是浅显的入门教程
- 要么对新手难以理解



我试着从不同的角度来处理这个领域，多年来，我终于找到了一条适合我的学习之路。不久前，我在Twitter上分享了这条路径，显然，它引起了很多人的共鸣：



本文并不是试图一蹴而就地解释容器。相反，它是我多年来对这个领域的研究的头版。它概述了上述的学习路径，然后引导你通过它，并指出在同一博客上更深入的文章。



掌握容器并不是一项简单的任务，所以不要着急，不要跳过动手操作的部分。



#### 容器学习路径



我发现下面的学习顺序特别有用：



- Linux容器——学习底层实现的细节。

- 容器图像——了解什么是图像以及为什么需要它们。
- 容器管理器——了解Docker如何帮助容器在单个主机上共存。
- 容器协调器——学习Kubernetes如何在集群中协调容器。非linux容器——学习其他实现来完成这个循环。



#### 容器不是虚拟机



容器是一个隔离的(名称空间)和受限制的(cgroups, capabilities, seccomp)进程。



以上的解释对我理解容器有很大帮助。当然，它不是非常准确，正如您将在本文末尾看到的那样，但在一开始，它非常适合学习目标。



![Containers work the same way on developer's laptop, CI/CD servers, and Kubernetes clusters running in the cloud.](https://iximiuz.com/container-learning-path/container-2000-opt.png)



[要启动一个 Linux 进程，你需要 fork/exec](https://iximiuz.com/en/posts/how-to-on-processes/)。但要启动一个容器化进程，首先需要创建名称空间、配置cgroups等。或者，换句话说，为进程在其中运行准备一个方框。容器运行时是一种用于创建此类盒的特殊类型(相当低级的)软件。典型的容器运行时知道如何准备容器，以及如何在其中启动容器化的进程。



最广泛使用的容器运行时是runc。由于runc是一个常规的命令行工具，所以可以直接使用它，而不需要 Docker 或任何其他更高级别的容器化软件！



![runc reparenting container process](https://iximiuz.com/container-learning-path/runc-foreground-stdio.png)



我被这一发现深深吸引，甚至写了一整系列关于集装箱运行垫片的文章。shim是位于低级容器运行时(如runc)和高级容器管理器(如containerd)之间的一段软件。由于垫片需要非常好地理解运行时的所有怪癖，本系列文章将从深入分析最广泛使用的容器运行时开始。



#### 运行容器，不需要镜像



但是需要容器来构建镜像。



对于熟悉runc如何启动容器的人来说，图像显然不是这个等式的一部分。相反，要运行一个容器，运行时需要一个由以下内容组成的所谓的bundle



- 一个配置。Json文件包含容器参数(可执行文件的路径，环境变量等)
- 包含上述可执行文件和支持文件的文件夹(如果有的话)。



通常，Bundle文件夹包含类似典型的Linux发行版（/ var，/ usr，/ lib，/ etc，...）的文件结构。当runc启动具有这样的捆绑包的容器时，内部的进程获取了一个根文件系统，看起来几乎就像你最喜欢的Linux味道，也是Debian，CentOS或Alpine。



但是这样的文件结构不是强制性的!所谓的无刮刮或无发行容器现在越来越流行，特别是因为更小的容器使得安全漏洞潜入的机会更少。



查看这篇文章，我展示了如何创建一个容器，其中只有一个Go二进制文件：https://iximiuz.com/en/posts/not-every-container-has-an-operating-system-inside/。




























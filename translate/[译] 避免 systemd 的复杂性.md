翻译自：[Avoiding complexity with systemd | Michael Maclean (mgdm.net)](https://mgdm.net/weblog/systemd/)



Unix 机器，从操作系统的诞生早期，即被设计为支持多用户同时使用。传统上，普通用户和系统服务，被设计为 “非特权用户”；而 root 用户，则被赋予执行有关系统的任何行为的权限。由于 Unix 中的大多数内容，均以文件的概念表示，因此，可以通过将用户添加到文件系统的组，以允许用户执行各种操作。还有其他函数，无法以这种方式委托，特别是绑定到某些 IP 端口。多年来，各种操作系统，都模糊这些内容。特别是在 Linux 上，这具有与 ACL 相同的功能，允许比标准的 Unix 权限模型，提供更多的控制。



```
Linux 比这更重要。有必要的访问控制系统，如 SELinux 或 Apparmor，可以让让你对系统有内核级别的控制。`cgroups` 和命名空间的功能相结合，以提供我们现在的控制容器。其他功能，如`seccomp`，允许软件选择，以使自身各种系统调用的能力。

BSD 操作系统，具有类似的特性，在 BSD 上，类似的功能是 `pledge` 和 `unveil`。
```



大部分原始许可模型都依然至今。 如果要运行侦听“众所周知的”端口的服务，则编号小于1024的服务，您通常需要root绑定到端口。 还有其他方法可以在Linux上允许这一点，例如将称为cap_net_bind_service的功能应用于要运行的程序，但是旨在在Unix系统中录制的大多数服务器软件实现了一个名为权限丢弃的功能。 该服务最初以root方式启动，绑定到它所需的端口，然后调用某些功能以将其自己的用户和组ID设置为非特权用户。 理想情况下，在做任何重要工作之前，它会这样做，以便最小化rootion在运行时发生的漏洞潜力。





